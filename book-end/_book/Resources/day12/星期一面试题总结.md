### 1. JWT



1 传统session认证存在一些问题：

1. 用户信息存储在内存中，用户规模大之后增加服务器开销；

2. 由于登录信息存储在内存中，限制了登录机器，不利于分布式站点。

 常规的JWT认证流程如下：

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20191025210342293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc4MTkzNg==,size_16,color_FFFFFF,t_70)

 相比于 session 认证，JWT省去了服务器存储用户信息的过程

2 JWT长什么样？

JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

3 JWT的构成

第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).

第一部分（header）: 对 header 进行base64 加密

第二部分（payload）: 对 payload 进行baase64 加密

第三部分（signature）: 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。

```
var encodedString = base64UrlEncode(header) + '.' +
base64UrlEncode(payload);
```

```
var signature = HMACSHA256(encodedString, 'secret'); TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

将这三部分用.连接成一个完整的字符串,构成了最终的jwt:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。

4 如何应用

一般是在请求头里加入Authorization，并加上Bearer标注：

```
 fetch('api/user/1', {

   headers: {

   'Authorization': 'Bearer ' + token

 }

})
```



服务端会验证token，如果验证通过就会返回相应的资源。整个流程就是这样的:



 2.总结:

优点

• 因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。

 • 因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。

 • 便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。

 • 它不需要在服务端保存会话信息, 所以它易于应用的扩展

 安全相关

• 不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。

 • 保护好secret私钥，该私钥非常重要。

 • 如果可以，请使用https协议



3. 加密算法中BASE64、MD5、SHA、HMAC等之间的区别

 [请参考](https://blog.csdn.net/lplj717/article/details/51828692)

 MD5、SHA、HMAC这三种加密算法，可谓是非可逆加密，就是不可解密的加密方法，我们称之为单向加密算法。我们通常只把他们作为加密的基础。单纯的以上三种的加密并不可靠。

1 BASE64

 Base64被定义为：Base64内容传送编码被设计用来把任意序列的8位字节描述为一种不易被人直接识别的形式。

常见于邮件、http加密，截取http信息，你就会发现登录操作的用户名、密码字段通过BASE64加密的。 

主要就是BASE64Encoder、BASE64Decoder两个类，我们只需要知道使用对应的方法即可。另，BASE加密后产生的字节位数是8的倍数，如果不够位数以=符号填充。

2 MD5

MD5 -- message-digest algorithm 5 （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值。好比现在的ISO校验，都是MD5校验。怎么用？当然是把ISO经过MD5后产生MD5的值。一般下载linux-ISO的朋友都见过下载链接旁边放着MD5的串。就是用来验证文件是否一致的。

 通常我们不直接使用上述MD5加密。通常将MD5产生的字节数组交给BASE64再加密一把，得到相应的字符串。

3 SHA

SHA(Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了， 但是SHA仍然是公认的安全加密算法，较之MD5更为安全。 

3 HMAC

HMAC(Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。





### 2nginx负载均衡

 网站的访问量越来越大，服务器的服务模式也得进行相应的升级，比如分离出数据库服务器、分离出图片作为单独服务，这些是简单的数据的负载均衡，将压力分散到不同的机器上。有时候来自web前端的压力，也能让人十分头痛。怎样将同一个域名的访问分散到两台或更多的机器上呢？这其实就是另一种负载均衡了，nginx自身就可以做到，只需要做个简单的配置就行。

 nginx不单可以作为强大的web服务器，也可以作为一个反向代理服务器，而且nginx还可以按照调度规则实现动态、静态页面的分离，可以按照轮询、ip哈希、URL哈希、权重等多种方式对后端服务器做负载均衡，同时还支持后端服务器的健康检查。

Nginx负载均衡一些基础知识：

nginx 的 upstream目前支持 4 种方式的分配 

1)、轮询（默认） 

 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 

2)、weight 

 指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 

2)、ip_hash 

 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 

3)、fair（第三方） 

 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 

4)、url_hash（第三方）



### 3类视图和def函数啥区别：

CBV:
	1、提高了代码的复用性，可以使用面向对象的技术
	2、可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提	      高了代码可读性
底层实现本质：
	3、实现本质： 基于反射实现的
	      流程：由路由---->as_view()方法--->view中的dispatch方法（反射实现的）
类试图的好处：
	1、代码可读性好
	2、类试图相对于函数试图有更高的复用性，如果其他地方需要用到某个类视图的特定逻辑时，可以直接继承该类试图

FBV:
	1、函数视图便于理解。但是遇到一个视图对应的路径提供了多种不同HTTP请求方式的支持时，便需要在一个函数中编写不同的业务逻辑，代码可读性与复用性都不佳。



### 4相比以前的函数视图，类视图有以下优势：

类是面向对象技术中非常重要的概念。具有复杂数据、功能的类，可以通过继承轻而易举的将自身特性传递给另一个类，从而实现代码的高效复用。

HTTP方法（GET，POST等）相关的代码，可以通过方法而不是条件分支来组织

可以通过诸如mixins（多重继承）之类的面向对象技术将代码分解为可重用组件





5.什么是LocalStorage

LocalStorage译为“本地存储器”，是HTML5中新增的一个存储对象，跟Cookie一样也是用来本地存储来的，但是解决了Cookie存储空间不足的问题(cookie每条存储空间为4k)，而localStorage浏览器一般支持5M，通常以键/值对形式的字符串进行存储。

### 什么是SessionStorage

SessionStorage译为“会话存储”，也是HTML5新增的一个存储对象， 用于本地临时存储同一窗口的数据，在关闭窗口之后将会删除这些数据，SessionStorage浏览器一般支持5M，通常以键/值对形式的字符串进行存储。

### LocalStorage与SessionStorage的区别

LocalStorage生命周期是永久,除非主动清除LocalStorage信息，否则这些信息将一直存放在客户端。而SessionStorage生命周期是临时，仅在当前会话窗口有效，关闭页面或浏览器数据就会自动被清除。



### LocalStorage与SessionStorage的特点

1.不同浏览器之间无法共享LocalStorage或SessionStorage中的数据。

2.LocalStorage和SessionStorage可以使用统一的API接口。

3.LocalStorage或SessionStorage通常以键/值对形式的字符串进行存储，所以在存储时需要对数据格式进行转换，使用JSON.stringify方法将对象转换成字符串，提取时用JSON.parse方法将字符串转换成对象。

4.LocalStorage或SessionStorage是HTML5的新属性，所以需要较新的浏览器才支持。

### LocalStorage与SessionStorage的用法

因为LocalStorage与SessionStorage的应用一致，这里就不多做解释了，以LocalStorage为例。

LocalStorage提供了5个方法，分别是clear（清除LocalStorage）、getItem（获取本地数据）、key（取下标对应键的值）、removeItem（删除以保存数据）、setItem（设置保存数据）。

下面是具体的使用方法和说明，直接用localStorage.就可以带出来对应的方法，我们只要理解其对应的应用属性就可以使用了。

这样我们就可以使用localStorage.setItem('键','值')将服务器传过来的数据存入客户端本地，存储前记得将数据进行转换。

### LocalStorage与SessionStorage应用实例

下面是我实际开发中的应用，前面我通过JsonResponse向前端发送了JSON数据，里面包含了data（用户请求的数据）、token（服务器生成的token）和code（后台处理的状态码），前端收到这些数据后对数据进行处理，判断code返回是否成功，如果成功我们就解析数据并将数据存入本地，否则则访问失败。



这里我用 localStorage和sessionStorage分别存了两个数据，localStorage是自定义的，sessionStorage是从后台获取的，打开浏览器开发者工具，在Application中我们可以在Storage下面的localStorage和sessionStorage分别找到我们存储的对应值。



#### 为什么用local storage存储

\- Cookie:若不设置过期时间，cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就会消失。cookie数据存放在客户的浏览器上，安全性低，存储数据小，



\- session：session数据放在服务器上，当访问量增多，会比较占用服务器的性能，

- local storage：始终有效，窗口或浏览器关闭也一直保存，因此用做持久化数据。
- session storage：关闭窗口后，sessionStorage就会被销毁，



\-  评论为什么用MongoDB存储不用MySQL？

​		 评论表结构比较简单，没有复杂的关联关系，所有可以选择MongoDB进行存储，MongoDB使用c++/boost编写，在大多数场合，其查询速度对比MySQL要快的多，对于CPU占用非常少，配置简单，



\- 上线之后怎么进行bug管理？

​		 可以使用禅道项目管理软件（工具），进行bug管理。



#### 怎么解决秒杀超卖问题

\- 如果在redis进行存储的话，可以使用redis分布式锁，或队列进行库存的变动，结合事务。如果是MySQL的话，事务加悲观或乐观锁结合使用。



6.非对称加密和对称加密对比

对称加密是一个秘钥，非对称加密是一对，两个秘钥

非对称加密比起对称加密更安全，因为不存在秘钥泄露问题，公钥即便被知道也没关系

由于使用非对称加密在计算上特别复杂，所以一般来说对称加密的加密解密的速度相对于非对称加密快很多

非对称秘钥还可以用于认证

由于以上第三条，所以在 https 中传输数据时不会使用非对称加密加密传输数据，传输数据时有可能数据本身很大，那样的话非对称加密更耗时了，所以传输数据时不会使用非对称加密的方式加密。



## 7.禅道bug系统管理流程

禅道里面的bug基本流程是：测试人员提出bug -> 开发人员解决bug -> 测试人员验证关闭。



### 8.递归

递归：递归上线998    
          1.在sys模块中提供了一个setrecursionlimit()的方法，用来修改递归次数限制
	import sys
	sys.setrecursionlimit（3000）
           2.更多选项，加载一部分，循环读取
webssh原理：
            1、xterm 在浏览器端模拟 shell 终端, 监听用户输入通过 websocket 将用户输入的内容上传到 django
            2、django 接受到用户上传的内容, 将用户在前端页面输入的内容通过 paramiko 建立的 ssh 通道上传到远程服务器执行
            3、paramiko 将远程服务器的处理结果返回给 django
            4、django 将 paramiko 返回的结果通过 websocket 返回给





### 9.索引

唯一索引：   
唯一索引是不允许其中任何两行具有相同索引值的索引。数据库还可能防止添加将在表中创建重复键值的新数据。例如，如果在 employee 表中职员的姓 (lname) 上创建了唯一索引，则任何两个员工都不能同姓。     

复合索引：
	1、复合索引也叫组合索引；
	2、两个或更多个列上的索引被称做复合索引；
	3、复合索引同时有两个概念叫做窄索引和宽索引,窄索引是指索引列为1-2列的索引,宽索引也就是索引列超过2列的索引

主键索引：   
数据库表经常有一列或列组合，其值唯一标识表中的每一行。该列称为表的主键。表定义主键将自动创建主键索引，主键索引是唯一索引的特定类型该索引要求主键中的每个值都唯一。当在查询中使用主键索引时，它还允许对数据的快速访问。


建立联合索引：
CREATE TABLE `test` (
	'aaa' VARCHAR (16) NOT NULL DEFAULT '',
	'bbb' VARCHAR (16) NOT NULL DEFAULT '',
	'ccc' INT (11) UNSIGNED NOT NULL DEFAULT 0,
	KEY `sindex` (`aaa`, `bbb`, `ccc`)
) ENGINE = MyISAM COMMENT = '';

这样就在 aaa、bbb、ccc 3列上建立联合索引了。 
建立这样的索引相当于建立了索引a、ab、abc三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。

索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页，哪个更高效，一眼便知





### 10.为什么要用rabbitmq

解耦、异步、削峰

1、解耦

传统模式的缺点：

系统间耦合性太强，如上图所示，系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！

中间件模式的的优点：

将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。

2、异步

传统模式的缺点：

一些非必要的业务逻辑以同步的方式运行，太耗费时间。

中间件模式:

中间件模式的的优点：

将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度

3、削峰

传统模式的缺点：

并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常

中间件模式的的优点：

系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。



使用了消息队列会有什么缺点?



分析:一个使用了MQ的项目，如果连这个问题都没有考虑过，就把MQ引进去了，那就给自己的项目带来了风险。

我们引入一个技术，要对这个技术的弊端有充分的认识，才能做好预防。要记住，不要给公司挖坑！

回答:回答也很容易，从以下两个个角度来答



系统可用性降低:



你想啊，本来其他系统只要运行好好的，那你的系统就是正常的。

现在你非要加个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性降低



系统复杂性增加:



要多考虑很多方面的问题，比如一致性问题、如何保证消息不被重复消费，如何保证保证消息可靠传输。

因此，需要考虑的东西更多，系统复杂性增大。

但是，我们该用还是要用的。



#### 消息队列如何选型?

ActiveMQ,RabbitMQ,RocketMQ,Kafka，对什么ZeroMQ等其他MQ没啥理解，因此只能基于这四种MQ给出回答。

综合上面的材料得出以下两点:

1、中小型软件公司，建议选RabbitMQ.

一方面，erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。

正所谓，成也萧何，败也萧何！他的弊端也在这里，虽然RabbitMQ是开源的，然而国内有几个能定制化开发erlang的程序员呢？

所幸，RabbitMQ的社区十分活跃，可以解决开发过程中遇到的bug，这点对于中小型公司来说十分重要。

不考虑rocketmq和kafka的原因是，一方面中小型软件公司不如互联网公司，数据量没那么大，选消息中间件，应首选功能比较完备的，所以kafka排除。

不考虑rocketmq的原因是，rocketmq是阿里出品，如果阿里放弃维护rocketmq，中小型公司一般抽不出人来进行rocketmq的定制化开发，因此不推荐。

2、大型软件公司，根据具体使用在rocketMq和kafka之间二选一

一方面，大型软件公司，具备足够的资金搭建分布式环境，也具备足够大的数据量。

针对rocketMQ,大型软件公司也可以抽出人手对rocketMQ进行定制化开发，毕竟国内有能力改JAVA源码的人，还是相当多的。

至于kafka，根据业务场景选择，如果有日志采集功能，肯定是首选kafka了。具体该选哪个，看使用场景。









# **什么是WebSocket**

WebSocket是HTML5规范提出的一种协议；目前除了完犊子的IE浏览器，其他浏览器都基本支持。他是一种协议，万变不离其宗，也是基于TCP协议的；和HTTP协议是并存的两种协议。

WebSocket是HTML5中的协议。HTML5 Web Sockets规范定义了Web Sockets API，支持页面使用Web Socket协议与远程主机进行全双工的通信。它引入了WebSocket接口并且定义了一个全双工的通信通道，通过一个单一的套接字在Web上进行操作。HTML5 Web Sockets以最小的开销高效地提供了Web连接。相较于经常需要使用推送实时数据到客户端甚至通过维护两个HTTP连接来模拟全双工连接的旧的轮询或长轮询（Comet）来说，这就极大的减少了不必要的网络流量与延迟。

要使用HTML5 Web Sockets从一个Web客户端连接到一个远程端点，你要创建一个新的WebSocket实例并为之提供一个URL来表示你想要连接到的远程端点。该规范定义了ws://以及wss://模式来分别表示WebSocket和安全WebSocket连接,这就跟http:// 以及https:// 的区别是差不多的。一个WebSocket连接是在客户端与服务器之间HTTP协议的初始握手阶段将其升级到Web Socket协议来建立的，其底层仍是TCP/IP连接。



# **WebSocket的特点**

（1）服务端可以主动推送信息，属于服务器推送技术的一种。

（2）建立在TCP协议之上，服务端的实现比较容易。

（3）与HTTP协议有着良好的兼容性，默认端口也是80和443，并且握手阶段采用HTTP协议，因此握手时不容易屏蔽，能通过各种HTTP代理服务器。

（4）数据格式比较轻量，性能开销小，通信高效。

（5）可以发送文本，也可以发送二进制数据。

（6）没有同源限制，客户端可以与任意服务器通信。

（7）协议标识符是ws（如果加密，则为wss），服务器网址就是URL。

#### **WebSocket与Socket的关系**

Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。

“Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口，提供一套调用TCP/IP协议的API。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。”

当两台主机通信时，必须通过Socket连接，Socket则利用TCP/IP协议建立TCP连接。TCP连接则更依靠于底层的IP协议，IP协议的连接则依赖于链路层等更低层次。

WebSocket就像HTTP一样，则是一个典型的应用层协议。

![img](http://localhost:4000/img/WebSockge1.png)

### **区别**

### **Socket是传输控制层协议，WebSocket是应用层协议。**

# **WebSocket与HTTP的关系**

# **相同点**

1. 都是一样基于TCP的，都是可靠性传输协议。

2. 都是应用层协议。

# **不同点**

1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。

2. WebSocket是需要握手进行建立连接的。

**联系**

WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

# **WebSocket 机制**

以下简要介绍一下 WebSocket 的原理及运行机制。

WebSocket 是 HTML5 一种新的协议。它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯，它建立在 TCP 之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大不同是：

WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/Client Agent 都能主动的向对方发送或接收数据，就像 Socket 一样；

WebSocket 需要类似 TCP 的客户端和服务器端通过握手连接，连接成功后才能相互通信。

非 WebSocket 模式传统 HTTP 客户端与服务器的交互如下图所示：

图 1. 传统 HTTP 请求响应客户端服务器交互图

![img](http://localhost:4000/img/WebSockge2.png)

使用 WebSocket 模式客户端与服务器的交互如下图

图 2.WebSocket 请求响应客户端服务器交互图

![img](http://localhost:4000/img/WebSockge3.png)

上图对比可以看出，相对于传统 HTTP 每次请求-应答都需要客户端与服务端建立连接的模式，WebSocket 是类似 Socket 的 TCP 长连接的通讯模式，一旦 WebSocket 连接建立后，后续数据都以帧序列的形式传输。在客户端断开 WebSocket 连接或 Server 端断掉连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实时性优势明显。

我们再通过客户端和服务端交互的报文看一下 WebSocket 通讯与传统 HTTP 的不同：

在客户端，new WebSocket 实例化一个新的 WebSocket 客户端对象，连接类似 ws://yourdomain:port/path 的服务端 WebSocket URL，WebSocket 客户端对象会自动解析并识别为 WebSocket 请求，从而连接服务端端口，执行双方握手过程，客户端发送数据格式类似

# **WebSocket 实现**

WebSocket 的实现分为客户端和服务端两部分，客户端（通常为浏览器）发出 WebSocket 连接请求，服务端响应，实现类似 TCP 握手的动作，从而在浏览器客户端和 WebSocket 服务端之间形成一条 HTTP 长连接快速通道。两者之间后续进行直接的数据互相传送，不再需要发起连接和相应。









## **缓存雪崩**

数据未加载到缓存中，或者缓存同一时间大面积的失效，从而导致所有请求都去查数据库，导致数据库CPU和内存负载过高，甚至宕机。

**比如一个雪崩的简单过程：**

1、redis集群大面积故障

2、缓存失效，但依然大量请求访问缓存服务redis

3、redis大量失效后，大量请求转向到mysql数据库

4、mysql的调用量暴增，很快就扛不住了，甚至直接宕机

5、由于大量的应用服务依赖mysql和redis的服务，这个时候很快会演变成各服务器集群的雪崩，最后网站彻底崩溃。

![img](https://pic2.zhimg.com/80/v2-cf0176503a1b5c51ff56d466de94060d_hd.jpg)

## **如何预防缓存雪崩：**

![img](https://pic4.zhimg.com/80/v2-38801b551891fb0b0dc4e6414b41c52b_hd.jpg)

**1.缓存的高可用性**

缓存层设计成高可用，防止缓存大面积故障。即使个别节点、个别机器、甚至是机房宕掉，依然可以提供服务，例如 Redis Sentinel 和 Redis Cluster 都实现了高可用。

**2.缓存降级**

可以利用ehcache等本地缓存(暂时支持)，但主要还是对源服务访问进行限流、资源隔离（熔断）、降级等。

当访问量剧增、服务出现问题仍然需要保证服务还是可用的。系统可以根据一些关键数据进行**自动降级**，也可以配置开关实现**人工降级，**这里会涉及到运维的配合。

**降级的最终目的是保证核心服务可用，即使是有损的。**

比如推荐服务中，很多都是个性化的需求，假如个性化需求不能提供服务了，可以降级补充热点数据，不至于造成前端页面是个大空白。

在进行降级之前要对系统进行梳理，比如：哪些业务是核心(必须保证)，哪些业务可以容许暂时不提供服务(利用静态页面替换)等，以及配合服务器核心指标，来后设置整体预案，比如：

（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；

（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；

（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；

（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

**3.Redis备份和快速预热**

1)Redis数据备份和恢复

2)快速缓存预热

**4.提前演练**

最后，建议还是在项目上线前，演练缓存层宕掉后，应用以及后端的负载情况以及可能出现的问题，对高可用提前预演，提前发现问题。

## **缓存穿透**

缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决思路：

如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库。设置一个过期时间或者当有值的时候将缓存中的值替换掉即可。

可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。

## **缓存并发**

这里的并发指的是多个redis的client同时set key引起的并发问题。其实redis自身就是单线程操作，多个client并发操作，按照先到先执行的原则，先到的先执行，其余的阻塞。当然，另外的解决方案是把redis.set操作放在队列中使其串行化，必须的一个一个执行。

## **缓存预热**

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。

这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

解决思路：

1、直接写个缓存刷新页面，上线时手工操作下；

2、数据量不大，可以在项目启动的时候自动进行加载；

目的就是在系统上线前，将数据加载到缓存中。

以上就是缓存雪崩、预热、降级等的介绍。







### mysql主从同步实现的原理?

mysql主从同步的原理很简单，从库生成两个线程，一个I/O线程，一个SQL线程；i/o线程去请求主库 的binlog（二进制日志），并将得到的binlog日志写到relay log（中继日志） 文件中；主库会生成一个 log dump 线程，用来给从库 i/o线程传binlog；SQL 线程，会读取relay log文件中的日志，并解析成具体操作，来实现主从的操作一致，而最终数据一致。

 

## 项目中是怎样查询优化的?

1、查询优化，避免走全表扫描，

2、应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，

3、between替换 in 或 not in

4、可考虑在使用”like %xx”的地方使用全文索引

5、需要查上面就选择什么，避免select * from xxx

7、避免”大查询”，当返回的数据量过大时，查询、网络传输、客户端解析显示都会变慢，考虑使用分页查询，而且一般用户一次性也看不了那么多数据。

8、有一个简单且实用的方式就是对数据库表添加索引。一般来说选择where、on、group by、order by后面的字段添加复合索引。

创建索引的方式:

```
create index index_name on app_mycust(字段名,...,....);
```

 

## 评论为啥用MongoDB而不存储到mysql 

 mysql 是关系型数据库,用于关联关系比较强的数据存储, 而mongodb 是最接近mysql的非关系型数据库, 评论呢在整个项目中与其他数据的关联关系不是特别的强, 且在后期数据量会非常的大,所以我们项目中就选择了mongo来存储评论信息.

 

## 项目里是否使用无限极分类是怎么实现的? 如果是递归又怎么解决无限级过度调用问题的

项目中的评论用到了无限级评论,盖楼式. 当时呢解决递归过度调用的问题,是使用了分页加载或点击更多加载 来每次去获取加载相应的数据.

 

## 递归的默认最大次数,怎样提高递归限度

```
#解决递归调用问题 可以使用:

import sys

sys.setrecursionlimit(100000)   #参数控制递归深度

def foo(n): 
	print(n) 
	n += 1 
	
foo(n) 
if __name__ == '__main__': 
	foo(1)

#这样可以让我们的递归深度 达到 3600左右
```

 

**而 以下的demo 可以完美解决递归调用的问题:**

```
import sys 
import types 
sys.setrecursionlimit(100000) 
def foo(n): 
	print(n) 
	if n==100000: 
		yield 1 
    else: n += 1 
    	yield foo(n) 
    	   	
def tramp(gen, arg): 
	g = gen(arg) 
	while isinstance(g, types.GeneratorType): 
		g=g.__next__() 
		return g 
if __name__ == '__main__':
	tramp(foo, 0)
```

 

 

## vue + django 项目为什么要使用这种框架

1.数据绑定：vue会根据对应的元素，进行设置元素数据，通过输入框，以及get获取数据等多种方式进行数据的实时绑定，进行网页及应用的数据渲染 。

2.组件式开发：通过vue的模块封装，它可以将一个web开发中设计的各种模块进行拆分，变成单独的组件，然后通过数据绑定，调用对应模版组件，同时传入参数，即可完成对整个项目的开发。

3.真正的实现了前后端分离

 

## CBV和 FBV 的区别

FBV（function base views） 基于函数的视图 CBV（class base views） 基于类的视图 

CBV:

**·** 优点

a. 提高了代码的复用性，可以使用面向对象的技术，比如说Mixin（多继承）

b. 可以用不同的函数针对不同的HTTP方法处理，而不是通过很多if判断，提高了代码可读性

**·** 实现本质： 基于反射实现的

· 流程：由路由---->as_view()方法--->view中的dispatch方法（反射实现的）

首先执行url中的as_view()方法

 

FBV:

基于函数实现的视图, 它必须要通过 if 去判断请求的方式, 再去 做 不同请求的数据处理, 也就是说 fbv 是基于过程的视图. 而 cbv 则是同步调用.

 

## Nginx负载均衡的实现和调度算法 

1、轮询（默认）

每个请求按时间顺序逐一分配到不同的后端服务，如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响。 

2、weight（轮询权值）

weight的值越大分配到的访问概率越高，主要用于后端每台服务器性能不均衡的情况下。或者仅仅为在主从的情况下设置不同的权值，达到合理有效的地利用主机资源。

3、ip_hash

每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。 

4、fair

比 weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间 来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块。 

5、url_hash

按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包。

 

正向代理:客户端 <一> 代理 一>服务端

正向代理简单地打个租房的比方:

A(客户端)想租C(服务端)的房子,

但是A(客户端)并不认识C(服务端)租不到。

B(代理)认识C(服务端)能租这个房子所以你找了B(代理)帮忙租到了这个房子。

这个过程中C(服务端)不认识A(客户端)只认识B(代理)

C(服务端)并不知道A(客户端)租了房子，只知道房子租给了B(代理)。

反向代理:客户端 一>代理 <一> 服务端

反向代理也用一个租房的例子:

A(客户端)想租一个房子,B(代理)就把这个房子租给了他。

这时候实际上C(服务端)才是房东。

B(代理)是中介把这个房子租给了A(客户端)。

这个过程中A(客户端)并不知道这个房子到底谁才是房东

他都有可能认为这个房子就是B(代理)的

由上的例子和图我们可以知道正向代理和反向代理的区别在于代理的对象不一样,正向代理的代理对象是客户端,反向代理的代理对象是服务端。

 

## 秒杀模块高并发以及超卖问题

 

CDN加速

页面静态化

redis缓存(为什么使用redis. 不使用memcache)

提前预加载(celery定时)

过滤无效请求

Nginx 反向代理

解决秒杀超卖问题

方案一：redis事物处理

我们可以使用redis中的监听（watch）方法，去监听库存数量，一旦库存数量在其他客户端发生改变，后续操作则会失败。

watch key1 key2 监听key1 key2有没有变化,如果有变, 则事务取消

 

 

方案二：redis分布式锁

分布式锁确保只有一个线程会操作库存，明哥在redis文集中有过专门的整理

1加锁（占个位置，后续的进不来）：

setnx命令: 只在键key不存在的情况下，将键key的值设置为value 。若键key已经存在， 则不做任何动作。

2解锁（用完了，就把位置让出来）：

del（key）

3锁超时（万一中间出现点意外，没有解锁，过几秒会自动释放） 

expire（key，30） 

 

方案三 : reids做队列

把每一件商品都lpush到redis队列中，利用lpop从队列中去取

 

## redis 雪崩 穿刺 问题 以及 数据类型; 底层数据结构的实现, 消息订阅模式实现原理; 和 rabbitmq作为队列的区别; 怎么去做数据持久化

 

缓存穿刺:

缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存。

想象一下这个情况，如果传入的参数为-1，会是怎么样？这个-1，就是一定不存在的对象。就会每次都去查询数据库，而每次查询都是空，每次又都不会进行缓存。假如有恶意攻击，就可以利用这个漏洞，对数据库造成压力，甚至压垮数据库。即便是采用UUID，也是很容易找到一个不存在的KEY，进行攻击。

我想到的解决办法就是 缓存空值的办法, 就是不管是否在数据库查到还是没有查到数据的存在 , 都把它 存到缓存当中

缓存雪崩:

缓存雪崩，是指在某一个时间段，缓存集中过期失效。从而导致了大量的请求落到了数据库上面, 从而产生周期性的压力波峰, 而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮。

缓存宕机的解决办法呢, 就是在过期时间上加上一个随机因子 , 这样能尽可能分散缓存过期时间