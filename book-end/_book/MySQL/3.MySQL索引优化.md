这部分可以阅读这篇文章：[MySQL数据库：索引（三）：索引的使用及优化](https://blog.csdn.net/a745233700/article/details/84455241)(https://blog.csdn.net/a745233700/article/details/84455241)

 

# 一、MySQL 索引简介

MySQL索引的建立对于MySQL的高效运行是很重要的，索引可以大大提高MySQL的检索速度。

打个比方，如果合理的设计且使用索引的MySQL是一辆兰博基尼的话，那么没有设计和使用索引的MySQL就是一个人力三轮车。

拿汉语字典的目录页（索引）打比方，我们可以按拼音、笔画、偏旁部首等排序的目录（索引）快速查找到需要的字。

索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。

创建索引时，你需要确保该索引是应用在 SQL 查询语句的条件(一般作为 WHERE 子句的条件)。

实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。

上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

建立索引会占用磁盘空间的索引文件。

 

## 普通索引

### 创建索引

这是最基本的索引，它没有任何限制。它有以下几种创建方式：

```
CREATE INDEX indexName ON mytable(username(length)); 
```

如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。

### 修改表结构(添加索引)

```
ALTER table tableName ADD INDEX indexName(columnName)
```

### 创建表的时候直接指定

```
CREATE TABLE mytable(  

 ID INT NOT NULL,  

username VARCHAR(16) NOT NULL,  

 INDEX [indexName] (username(length))  

 );  
```

### 删除索引的语法

```
DROP INDEX [indexName] ON mytable; 
```

## 唯一索引

它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：

### 创建索引

```
CREATE UNIQUE INDEX indexName ON mytable(username(length)) 
```

### 修改表结构

```
ALTER table mytable ADD UNIQUE [indexName] (username(length))
```

### 创建表的时候直接指定

```
CREATE TABLE mytable(  

ID INT NOT NULL,  

username VARCHAR(16) NOT NULL,  

UNIQUE [indexName] (username(length))  

 );  
```

## 使用ALTER 命令添加和删除索引

有四种方式来添加数据表的索引：

**·** ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。

**·** ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。

**·** ALTER TABLE tbl_name ADD INDEX index_name (column_list):添加普通索引，索引值可出现多次。

**·** ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):该语句指定了索引为 FULLTEXT ，用于全文索引。

以下实例为在表中添加索引。

```
mysql> ALTER TABLE testalter_tbl ADD INDEX (c);
```

你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:

```
mysql> ALTER TABLE testalter_tbl DROP INDEX c;
```

 

## 使用 ALTER 命令添加和删除主键

主键只能作用于一个列上，添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：

```
mysql> ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;

mysql> ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);
```

你也可以使用 ALTER 命令删除主键：

```
mysql> ALTER TABLE testalter_tbl DROP PRIMARY KEY;
```

删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。

 

## 显示索引信息

你可以使用 SHOW INDEX 命令来列出表中的相关的索引信息。可以通过添加 \G 来格式化输出信息。

尝试以下实例:

```
mysql> SHOW INDEX FROM table_name; \G
```

 

# 二、MySQL 索引存储

 

Mysql索引主要有两种结构：B-Tree索引和Hash索引.

### Hash索引

MySQL中，只有Memory（Memory表只存在内存中，断电会消失，适用于临时表）存储引擎显式支持Hash索引，是Memory表的默认索引类型。Memory表也可以使用B-Tree索引。Hsah索引把数据的索引以hash形式组织起来，因此当查找某一条记录的时候，速度非常快。由于Hsah索引是hash结构，每个键只对应一个值，而且是散列的方式分布，所以并不支持范围查找和排序等功能。

### B-Tree索引

B-Tree是MySQL使用最频繁的一个索引数据结构，是InnoDB和MyISAM存储引擎的索引类型。相对Hash索引，B-Tree索引在查找单条记录的速度比不上Hash索引，但是因为更适合排序等操作，所以更受用户的欢迎。

· 带顺序访问指针的B-Tree

B-Tree所有索引数据都在叶子结点上，并且增加了顺序访问指针，每个叶子节点都有指向相邻叶子节点的指针。这样做是为了提高区间查询效率。例如查询key为从100到200的所有数据记录，当找到100后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。

· 大大减少磁盘I/O读取

数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。
为了达到这个目的，在实际实现B+Tree还使用如下技巧：
（1）每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。

（2）B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为O(h)=O(logdN)。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。

 

三、 MySQL 索引优缺点、分类

l 优点：

　　　1、所有的MySql列类型(字段类型)都可以被索引，也就是可以给任意字段设置索引

　　　2、大大加快数据的查询速度

l 缺点：

　　　1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加

　　　2、索引也需要占空间，我们知道数据表中的数据也会有最大上线设置的，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值

　　　3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。

l 使用原则：

　　　通过上面说的优点和缺点，我们应该可以知道，并不是每个字段度设置索引就好，也不是索引越多越好，而是需要自己合理的使用。

　　　1、对经常更新的表就避免对其进行过多的索引，对经常用于查询的字段应该创建索引，

　　　2、数据量小的表最好不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。

　　　3、在一同值少的列上(字段上)不要建立索引，比如在学生表的"性别"字段上只有男，女两个不同值。相反的，在一个字段上不同值较多可以建立索引。

 

## 索引的分类

　　　注意：索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引

　　　MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换MEMORY/HEAP存储引擎：支持HASH和BTREE索引

l 索引我们分为四类来讲 单列索引(普通索引，唯一索引，主键索引)、组合索引、全文索引、空间索引、

n 单列索引：一个索引只包含单个列，但一个表中可以有多个单列索引。 这里不要搞混淆了。

u 普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。

u 唯一索引：索引列中的值必须是唯一的，但是允许为空值。

u 主键索引：是一种特殊的唯一索引，不允许有空值。

n 组合索引:在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

n 全文索引:只有在MyISAM引擎上才能使用，只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引，介绍了要求，说说什么是全文索引，就是在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行，比如有"你是个靓仔，靓女 ..." 通过靓仔，可能就可以找到该条记录。这里说的是可能，因为全文索引的使用涉及了很多细节，我们只需要知道这个大概意思。

n 空间索引:是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。在创建空间索引时，使用SPATIAL关键字。要求，引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。

# 四、MySQL 索引优化规则

 

1、like语句的前导模糊查询不能使用索引： 

```
select * from doc where title like '%XX'；  --不能使用索引

select * from doc where title like 'XX%'；  --非前导模糊查询，可以使用索引
```

因为页面搜索严禁左模糊或者全模糊，如果需要可以使用搜索引擎来解决。

 

2、union、in、or 都能够命中索引，建议使用 in。 

（1）union：能够命中索引，并且MySQL 耗费的 CPU 最少。

```
select * from doc where status=1

union all

select * from doc where status=2;
```

（2）in：能够命中索引，查询优化耗费的 CPU 比 union all 多，但可以忽略不计，一般情况下建议使用 in。

```
select * from doc where status in (1, 2);
```

（3）or：新版的 MySQL 能够命中索引，查询优化耗费的 CPU 比 in 多，不建议频繁用 or。

```
select * from doc where status = 1 or status = 2 
```

（4）补充：有些地方说在where条件中使用or，索引会失效，造成全表扫描，这是个误区：

①要求where子句使用的所有字段，都必须建立索引； 

②如果数据量太少，mysql制定执行计划时发现全表扫描比索引查找更快，所以会不使用索引； 

③确保mysql版本5.0以上，且查询优化器开启了index_merge_union=on, 也就是变量optimizer_switch里存在index_merge_union且为on。

 

3、负向条件查询不能使用索引：

```
负向条件有：!=、<>、not in、not exists、not like 等。
```

例如下面SQL语句：

```
select * from doc where status != 1 and status != 2;
```

可以优化为 in 查询：

```
select * from doc where status in (0,3,4);
```

4、联合索引最左前缀原则：

如果在(a,b,c)三个字段上建立联合索引，那么他会自动建立 a | (a,b) | (a,b,c) 三组索引。 

例如登录业务需求，SQL语句如下： 

```
select uid, login_time from user where login_name=? andpasswd=?；
```

可以建立(login_name, passwd)的联合索引。因为业务上几乎没有 passwd 的单条件查询需求，而有很多 login_name 的单条件查询需求，所以可以建立(login_name, passwd)的联合索引，而不是(passwd, login_name)。

（1）建立联合索引的时候，区分度最高的字段在最左边：

 （2）存在非等号和等号混合判断条件时，在建立索引时，把等号条件的列前置：

 如 where a>? and b=?，那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。

 （3）最左前缀查询时，并不是指SQL语句的where顺序要和联合索引一致：

 下面的 SQL 语句也可以命中 (login_name, passwd) 这个联合索引：

```
select uid, login_time from user where passwd=? andlogin_name=?
```

但还是建议 where 后的顺序和联合索引一致，养成好习惯。

（4）假如index(a,b,c), where a=3 and b like 'abc%' and c=4，a能用，b能用，c不能用。

 

5、不能使用索引中范围条件右边的列（范围列可以用到索引），范围列之后列的索引全失效：

 范围条件有：<、<=、>、>=、between等。

 索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。

 假如有联合索引 (empno、title、fromdate)，那么下面的 SQL 中 emp_no 可以用到索引，而title 和 from_date 则使用不到索引。

```
select * from employees.titles where emp_no < 10010' and title='Senior Engineer'and from_date between '1986-01-01' and '1986-12-31'
```



6、不要在索引列上面做任何操作（计算、函数），否则会导致索引失效而转向全表扫描：

例如下面的 SQL 语句，即使 date 上建立了索引，也会全表扫描：

```
select * from doc where YEAR(create_time) <= '2016';
```

可优化为值计算，如下：

```
select * from doc where create_time <= '2016-01-01';
```

比如下面的 SQL 语句：

```
select * from order where date < = CURDATE()；
```

可以优化为：

```
select * from order where date < = '2018-01-2412:00:00';
```



7、强制类型转换会全表扫描：

字符串类型不加单引号会导致索引失效，因为mysql会自己做类型转换,相当于在索引列上进行了操作。 

如果 phone 字段是 varchar 类型，则下面的 SQL 不能命中索引。

```
select * from user where phone=13800001234
```

可以优化为：

```
select * from user where phone='13800001234';
```



8、更新十分频繁、数据区分度不高的列不宜建立索引：

更新会变更 B+ 树，更新频繁的字段建立索引会大大降低数据库性能。

“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似。

一般区分度在80%以上的时候就可以建立索引，区分度可以使用 count(distinct(列名))/count(*) 来计算。

 

9、利用覆盖索引来进行查询操作，避免回表，减少select * 的使用 ：

覆盖索引：查询的列和所建立的索引的列个数相同，字段相同。

被查询的列，数据能从索引中取得，而不用通过行定位符 row-locator 再到 row 上获取，即“被查询列要被所建的索引覆盖”，这能够加速查询速度。

例如登录业务需求，SQL语句如下。

```
Select uid, login_time from user where login_name=? and passwd=?
```

可以建立(login_name, passwd, login_time)的联合索引，由于 login_time 已经建立在索引中了，被查询的 uid 和 login_time 就不用去 row 上获取数据了，从而加速查询。



10、索引不会包含有NULL值的列：

 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时，尽量使用not null 约束以及默认值。



 11、is null, is not null无法使用索引：

 

12、如果有order by、group by的场景，请注意利用索引的有序性：

 （1）order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort 的情况，影响查询性能。

 例如对于语句 where a=? and b=? order by c，可以建立联合索引(a,b,c)。

 （2）如果索引中有范围查找，那么索引有序性无法利用，如 WHERE  a>10 ORDER BY b;，索引(a,b)无法排序。



 13、使用短索引（前缀索引）：

对列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果该列在前10个或20个字符内，可以做到既使得前缀索引的区分度接近全列索引，那么就不要对整个列进行索引。因为短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作，减少索引文件的维护开销。可以使用count(distinct leftIndex(列名, 索引长度))/count(*) 来计算前缀索引的区分度。

 但缺点是不能用于 ORDER BY 和 GROUP BY 操作，也不能用于覆盖索引。

 不过很多时候没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。



14、利用延迟关联或者子查询优化超多分页场景：

 MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。

 示例如下，先快速定位需要获取的 id 段，然后再关联:

```
selecta.* from 表1 a,(select id from 表1 where 条件 limit100000,20 ) b where a.id=b.id；
```



15、如果明确知道只有一条结果返回，limit 1 能够提高效率。

 比如如下 SQL 语句： 

```
select * from user where login_name=?;
```

可以优化为： 

```
select * from user where login_name=? limit 1
```

自己明确知道只有一条结果，但数据库并不知道，明确告诉它，让它主动停止游标移动。

 

16、超过三个表最好不要 join：

 需要 join 的字段，数据类型必须一致，多表关联查询时，保证被关联的字段需要有索引。

 例如：left join是由左边决定的，左边的数据一定都有，所以右边是我们的关键点，建立索引要建右边的。当然如果索引在左边，可以用right join。

 

17、单表索引建议控制在5个以内。



 18、SQL 性能优化 explain 中的 type：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。

 consts：单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。

 ref：使用普通的索引（Normal Index）。

 range：对索引进行范围检索。

 当 type=index 时，索引物理文件全扫，速度非常慢。



 19、业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引：

 不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的。另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。



 20.创建索引时避免以下错误观念：

 （1）索引越多越好，认为需要一个查询就建一个索引。

 （2）宁缺勿滥，认为索引会消耗空间、严重拖慢更新和新增速度。

 （3）抵制惟一索引，认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。

 （4）过早优化，在不了解系统的情况下就开始优化。

 

## 总结

1 索引是排好序且快速查找的数据结构。其目的是为了提高查询的效率。
2 创建索引后，查询数据变快，但更新数据变慢。
3 性能下降的原因很可能是索引失效导致。
4 索引创建的原则，经常查询的字段适合创建索引，频繁需要更新的数据不适合创建索引。
5 索引字段频繁更新，或者表数据物理删除容易造成索引失效。
6 擅用 explain 分析sql语句
7 除了优化sql语句外，还可以优化表的设计。如尽量做成单表查询，减少表之间的关联。设计归档表等。