[tornado框架的异步非阻塞](https://www.cnblogs.com/becker/p/9335136.html) 参考博客

### tornado介绍

```python
tornado是一个用python编写的一个强大的、可拓展的异步HTTP服务器，同时也是一个web开发框架
tornado是一个非阻塞式web服务器，其速度相当快。得利于其非阻塞的方式和对epoll的运用，tornado每秒可以处理数以千计的连接
```



### 与其他框架对比

```python
主要和Django为代表的传统框架进行比较，这一类的Python web应用部署的时候一般是采用WSGI协议与服务器对接的，而这类服务器通常是基于多线程/多进程的，也就是说每有一个网络请求，服务器都会有一个线程/进程进行处理。

WSGI是个同步模型，不支持非阻塞的请求方式，Tornado默认是不推荐使用WSGI的，如果在Tornado中使用WSGI，将无法使用Tornado的异步非阻塞的处理方式，相应的异步接口也就无法使用，性能方面也就大打折扣，这个也是Tornado性能如此优越的原因。
```



### 同步与异步

同步是指一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成。

异步是指不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作。然后继续执行下面代码逻辑，只要自己完成了整个任务就算完成了（异步一般使用状态、通知和回调）



### 阻塞与非阻塞

阻塞是指调用结果返回之前，当前线程会被挂起，一直处于等待消息通知，不能够执行其他业务（大部分代码都是这样的）

非阻塞是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回（继续执行下面代码，或者重试机制走起）



### 五种IO模型

1. 阻塞式IO：
   + 当用户进程调用了`recvfrom`等阻塞方法时，内核进入IO的第1个阶段：准备数据（内核需要等待足够的数据再拷贝）这个过程需要等待，用户进程会被阻塞，等内核将数据准备好，然后拷贝到用户地址空间，内核返回结果，用户进程才从阻塞态进入就绪态
   + Linux中默认情况下所有的socket都是阻塞的
2. 非阻塞式IO：
   + 当用户进程发出read操作时，如果`kernel`中的数据还没有准备好，那么它并不会`block`用户进程，而是立刻返回一个`error`
   + 用户进程判断结果是一个`error`时，它就知道数据还没有准备好，于是它可以再次发送read操作
   + 一旦`kernel`中的数据准备好了，并且又再次收到了用户进程的`system call`，那么它马上就将数据拷贝到了用户内存，然后返回
   + 非阻塞IO模式下用户进程需要不断地询问内核的数据准备好了没有
3. **IO多路复用：**
   + 通过一种机制，一个进程可以监视多个文件描述符（套接字描述符）一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作（这样就不需要每个用户进程不断的询问内核数据准备好了没）
   + 常用的IO多路复用方式有`select`、`poll`和`epoll`
4. 信号驱动IO：
   + 内核文件描述符就绪后，通过信号通知用户进程，用户进程再通过系统调用读取数据。
   + 此方式属于同步IO（实际读取数据到用户进程缓存的工作仍然是由用户进程自己负责的）
5. 异步IO（`POSIX`的`aio_`系列函数）
   + 用户进程发起read操作之后，立刻就可以开始去做其它的事。内核收到一个异步`IO read`之后，会立刻返回，不会阻塞用户进程。
   + 内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个`signal`告诉它read操作完成了



### tornado底层(处理多连接高并发)

> 一、传统的循环遍历的方式处理多个连接

这种方式明显的缺点就是，当其中任何一个socket的文件数据不ready的时候，线程/进程会一直等待，进而导致后面要处理的连接都被阻塞，整个应用也就阻塞了。



> 二、select技术	select本身是一个系统的调用函数

*select 的中文含义是”选择“，select机制也如其名，监听一些 server 关心的套接字、文件等对象，关注他们是否可读、可写、发生异常等事件。一旦出现某个 select 关注的事件，select 会对相应的套接字或文件进行特定的处理，这就是 select 机制最主要的功能。*

select 机制可以只使用一个进程/线程来处理多个socket或其他对象，因此又被称为I/O复用。

```python
int select(int nfds, fd_set readfds, fd_set writefds,fd_set exceptfds, const struct  timeval  timeout);
```

实现过程:

1. 首先fdset集合里需要监控的文件句柄由程序员来添加，当前连接需要监控哪些文件句柄，那么通过FD_SET宏来进行添加。
2. 然后调用select()函数将fd_set从用户空间拷贝到内核空间。
3. 注册一个回调函数。
4. 内核对文件句柄进行监控。
5. 当有满足可读写等条件时/超时调用回调函数并将文件句柄**集合**拷贝回用户空间。
6. 应用通过轮询的方式查找所有文件句柄，用FD_ISSET宏来判读具体是哪个文件句柄可操作。
7. 根据已经就绪的文件句柄发送数据,并将文件句柄从集合中删除。
8. 当再次有新连接处理需要监控，再次重复以上步骤往内核拷贝fdset。

优点：跨平台

缺点分析:

1. 句柄上限： 单个进程通过轮询的方式监控所有的文件句柄，当文件句柄越多，处理的效率越低，为了保证效率，文件句柄也就设置了上限，这个上限和内存也是有一定关系的，32位机默认是1024。

   解决方案: 不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。

2. 重复初始化：每次监控都重复将fdset从用户空间拷贝到内核空间，然后又从内核空间拷贝到用户空间，这个过程重复比较耗费系统资源。

3. 逐个排查文件(线性扫描)效率不高： 检测哪些文件句柄可操作时，采用的是轮询遍历所有的文件句柄，用FD_ISSET宏来判断文件句柄是否可操作，然而实际情况，大部分文件句柄是不可操作的，这种逐个排查的方式效率太低。![io_select](../img/tornado/io_select.png)

参数解析:

1. FD_ZERO(fd_set *fdset);将指定的文件描述符集清空，在对文件描述符集合进行设置前，必须对其进行初始化，如果不清空，由于在系统分配内存空间后，通常并不作清空处理，所以结果是不可知的。
2. FD_SET(fd_set *fdset);用于在文件描述符集合中增加一个新的文件描述符。
3. FD_ISSET(int fd,fd_set *fdset);用于测试指定的文件描述符是否在该集合中。
4. FD_CLR(fd_set *fdset);用于在文件描述符集合中删除一个文件描述符。

 

> 三、poll技术

poll技术与select 技术本质上是没有区别的，只是文件句柄的存储结构变更了，变成了链表，所以没有了文件句柄的上限，但是其他缺点依旧存在。

缺点: 大量的fd_set被整体复制于用户空间和内核空间之间

补充: select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候 将 再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。



> 四、epoll技术(tornado的核心)

epoll技术整个流程其实和select、poll技术大体上是一样的，主要是针对造成效率低下的点进行优化，可以说是将select和poll技术的缺点一一解决才达到现在的高效率，接下来我们一一道来：

1. 句柄上限 句柄上限的问题poll技术已经解决了。

2. 重复初始化 这个问题就像中学时候读书书包带课本一样(中学的课程数量和书本数量之多大家应该都懂的)，每天上学把所有几十本课本从家里背到学校，放学了再从学校将所有书背回家，但你今天家庭作业实际需要带的书可能就个别课程的个别几本书而已。

   所以为了减轻我们身体的负担，是不是放学的时候只带几本今天需要做家庭作业的几本书就很轻松了，同样的为了减少重复初始化过程中用户空间和内核空间发生不必要的拷贝带来的资源浪费，epoll技术提供了epoll_ctl函数，在用epoll_ctl函数进行事件注册的时候，会将文件句柄都复制到内核中，所以不用每次都复制一遍，当有新的文件句柄时采用的也是增量往内核拷贝，确保了每个文件句柄只会被拷贝一次。

   ```python
   epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。
   ```

   

3. 解决select逐个排查文件效率不高的问题,epoll会用epoll_ctl为每个文件句柄注册一个回调函数，同时会在内核中通过epoll_create创建一个专用链表（还有包含存储fd的专用内存空间），当有文件句柄状态发生变更，通过回调函数会将状态发生变更的文件句柄加入该链表，epoll技术还提供了epoll_wait函数，来查看链表中有没有就绪的文件句柄，然后只将该链表中的就绪文件句柄从内核空间拷贝到用户空间，这样一来就不用遍历每个文件句柄，只处理状态发生变更的，效率自然就提升上去了。

总结一下，epoll技术提供了三个系统调用函数：

- epoll_create：用于创建和初始化一些内部使用的数据结构。
- epoll_ctl： 用于注册时间、添加、删除和修改指定的df及其期待的事件。
- epoll_wait: 用于等待先前指定的fd事件，即就绪的fd。

通过以上三点解决方案，epoll技术的效率相比select、poll技术效率大大提升了，Tornado自然也采用了epoll技术，通过这种技术也就解决了著名的C10k问题，实现了用一个进程/线程来同时处理若干个连接的想法，减少了硬件资源的浪费。

```python
注意：如果没有大量的idle-connection(闲置连接)或者dead-connection（废弃连接），epoll的效率并不会比select/poll高很多，但是当遇到大量的idle-connection，就会发现epoll的效率大大高于select/poll。
```



**epoll优点总结**

1. epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。

2. epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描 述符数量的 值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在 系统调用时复制的开销。

3. 另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某 个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。(此处去掉了遍历文件描述符，而是通过监听回调的的机制。这正是epoll的魅力所在。)

4. 没有最大(很大)并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）。

**epoll对文件描述符的操作模式**

1. LT（level trigger）：默认模式

   LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。

2. ET（edge trigger）：

   ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。

   ```python
   ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
   ```

### 三者的区别

1. 支持一个进程所能打开的最大数

   ![最大连接数](C:\Users\Lenovo\Desktop\最大连接数.png)

2. FD剧增后带来的IO效率问题

   ![FD剧增](C:\Users\Lenovo\Desktop\FD剧增.png)

3. 消息传递方式

   ![消息传递方式](C:\Users\Lenovo\Desktop\消息传递方式.png)

```python
综上，在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点：
1、表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。
2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。
```



### tornado请求的生命周期

1. 首先Tornado需要建立监听，会创建一个socket用于监听，如果有客户端A请求建立连接之后，Tornado会基于原先的socket新创建一个包含客户端A连接的有关信息的socket(分配新的监听端口)，用于监听和客户端A的请求。此时对Tornado来说就有两个socket需要进行监控，原先的socket继续用来监听建立新连接，新的socket用于和客户端A进行通信，假如没有epoll技术的话，Tornado需要自己去循环询问哪个socket有新的请求。
2. 有了epoll技术，Tornado只需要把所有的socket丢给epoll，epoll作为管家帮忙监控，然后Torando.ioloop.IOLoop.current().start()开启循环，不断的去询问epoll是否有请求需要处理，这就是ioloop所做的工作，也是Tornado的核心部分。
3. 当有客户端进行请求，epoll就发现有socket可处理，当ioloop再次询问epoll时，epoll就把需要处理的socket交由Tornado处理
4. Tornado对请求进行处理，取出报文，从报文中获取请求路径，然后从tornado.web.Applcation里配置的路由映射中把请求路径映射成对应的处理类
5. 处理类处理完成后，生成响应，将响应内容封装成http报文，通过请求时建立的连接（尚未中断）将响应内容返回给客户端。
6. 当有多个请求同时发生，Tornado会按顺序挨个处理。



### tornado的应用场景

如果选择性能,tornado首选;要开发速度,Django和Flask都可以,区别是Flask把许多功能都交给第三方库来完成了,因此Flask更为灵活。Django适合初学者或者小团队的快速开发，适合做管理类、博客类网站、或者功能十分复杂需求十分多的网站，Tornado适合高度定制，适合访问量大，异步情况多的网站。

